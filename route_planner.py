# route_planner.py
#
# Description:
# This script reads a KML file containing a street network (generated by
# street_network_to_kml.py), models it as a graph, and calculates an
# optimal route that traverses every street at least once (solving the
# Chinese Postman Problem). It outputs the final route as a new KML file
# and a text file with turn-by-turn directions.
#
# Prerequisites:
# - Python 3
# - 'fastkml' library: pip install fastkml
# - 'networkx' library: pip install networkx
# - 'haversine' library: pip install haversine
# - 'simplekml' library: pip install simplekml

import sys
import networkx as nx
from fastkml import kml
from haversine import haversine
import simplekml

# A tolerance for considering two coordinate points to be the same intersection.
# (Value is in degrees latitude/longitude).
COORDINATE_PRECISION = 4 # e.g., 1.123456

def parse_kml_to_graph(kml_file):
    """
    Parses a KML file and builds a graph representation of the street network.

    Args:
        kml_file (str): Path to the input KML file.

    Returns:
        networkx.MultiGraph: A graph where nodes are intersections and edges
                             are street segments.
    """
    print(f"Reading and parsing {kml_file}...")
    try:
        with open(kml_file, 'rt', encoding='utf-8') as f:
            doc = f.read().encode("utf-8")
        k = kml.KML()
        k = k.from_string(doc)
    except Exception as e:
        print(f"Error reading or parsing KML file: {e}", file=sys.stderr)

        return None

    # The graph allows for multiple edges between the same two nodes.
    graph = nx.MultiGraph()
    # A dictionary to get all features from the KML, which are the LineStrings.
    features = list(list(k.features)[0].features)

    for feature in features:
        if not hasattr(feature, 'geometry'):
            continue

        geom = feature.geometry
        # Coords are (lon, lat, alt), so we take the first two elements.
        coords = [(round(lon, COORDINATE_PRECISION), round(lat, COORDINATE_PRECISION)) for lon, lat, _ in geom.coords]
        
        # An edge is a segment between two consecutive points in the LineString.
        for i in range(len(coords) - 1):
            start_node = coords[i]
            end_node = coords[i+1]

            # Calculate the distance (weight) of the edge.
            # haversine expects (lat, lon).
            distance = haversine(
                (start_node[1], start_node[0]),
                (end_node[1], end_node[0])
            )

            graph.add_edge(
                start_node,
                end_node,
                name=feature.name,
                weight=distance,
                coords=[start_node, end_node]
            )
            
    print(f"Graph built successfully with {graph.number_of_nodes()} nodes (intersections) and {graph.number_of_edges()} edges (street segments).")
    return graph

def generate_route_instructions(edge_list):
    """Generates simple turn-by-turn directions from the edge list."""
    if not edge_list:
        return "No route found.", []

    instructions = []
    full_path_coords = []
    
    # Start with the first street.
    current_street_name = edge_list[0][2].get('name', 'Unnamed Street')
    instructions.append(f"Start on {current_street_name}")
    
    # The first coordinate of the first edge.
    full_path_coords.extend(edge_list[0][2].get('coords'))

    for i in range(len(edge_list) - 1):
        current_edge_data = edge_list[i][2]
        next_edge_data = edge_list[i+1][2]
        
        next_street_name = next_edge_data.get('name', 'Unnamed Street')
        
        if current_street_name != next_street_name:
            instructions.append(f"Turn onto {next_street_name}")
            current_street_name = next_street_name
            
        # Add the coordinates of the next segment.
        # To avoid duplicate points at intersections, just add the end point.
        full_path_coords.append(next_edge_data.get('coords')[1])

    instructions.append("Route finished.")
    return "\n".join(instructions), full_path_coords

def create_output_files(route_coords, instructions_text, output_kml_file, output_txt_file):
    """Saves the final route to KML and TXT files."""
    # Create KML file for the route
    kml_out = simplekml.Kml(name="Planned Route", description="Optimal route covering all streets.")
    linestring = kml_out.newlinestring(name="Full Route")
    linestring.coords = route_coords
    linestring.style.linestyle.color = simplekml.Color.red
    linestring.style.linestyle.width = 5
    
    try:
        kml_out.save(output_kml_file)
        print(f"\nSuccessfully saved route to: {output_kml_file}")
    except Exception as e:
        print(f"Error saving KML file: {e}", file=sys.stderr)

    # Create TXT file for directions
    try:
        with open(output_txt_file, 'w', encoding='utf-8') as f:
            f.write(instructions_text)
        print(f"Successfully saved directions to: {output_txt_file}")
    except Exception as e:
        print(f"Error saving TXT file: {e}", file=sys.stderr)

def main():
    """Main execution function."""
    input_kml = "test_small.kml"
    output_route_kml = "planned_route.kml"
    output_route_txt = "route_directions.txt"
    
    print("-" * 50)
    print("Street Network Route Planner")
    print("-" * 50)

    # 1. Build the graph from the KML file.
    graph = parse_kml_to_graph(input_kml)
    if not graph:
        return

    # 2. Check if the graph is connected.
    if not nx.is_connected(graph):
        print("Warning: The street network is not fully connected.", file=sys.stderr)
        print("The route will be calculated for the largest connected area.", file=sys.stderr)
        # Find the largest connected component and work with that
        largest_component = max(nx.connected_components(graph), key=len)
        graph = graph.subgraph(largest_component).copy()

    # 3. Make the graph Eulerian.
    # This adds the minimum number of edges to make all node degrees even.
    print("Solving the Chinese Postman Problem by making the graph Eulerian...")
    eulerian_graph = nx.eulerize(graph)
    print("Graph has been eulerized.")

    # 4. Find the Eulerian circuit in the new graph.
    # This circuit traverses every edge, including the newly added ones.
    print("Calculating the final route (Eulerian circuit)...")
    start_node = list(eulerian_graph.nodes())[0]
    
    # This gives us a list of edges in the order they should be traversed.
    # The format is (node1, node2, key), but we need the edge data.
    circuit_edge_keys = list(nx.eulerian_circuit(eulerian_graph, source=start_node))
    
    # Get the full edge data (including name and coords) for each edge in the circuit.
    circuit_edges = []
    for u, v in circuit_edge_keys:
        # We need to find the specific edge instance, as there can be multiple.
        # This is a bit of a workaround to get the right edge data.
        edge_data = eulerian_graph.get_edge_data(u, v)
        # In a MultiGraph, edge_data is a dict of keys to attributes.
        # We assume taking the first one that hasn't been "used" works.
        # A more robust solution might be needed for complex graphs.
        key = list(edge_data.keys())[0]
        circuit_edges.append((u, v, edge_data[key]))
        
    print("Route calculated.")

    # 5. Generate human-readable directions and a single coordinate path.
    instructions, route_coords = generate_route_instructions(circuit_edges)

    # 6. Save the output files.
    create_output_files(route_coords, instructions, output_route_kml, output_route_txt)
    
    print("\nProcess complete.")


if __name__ == "__main__":
    main()
