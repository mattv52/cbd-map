# route_planner.py
#
# Description:
# This script reads a KML file containing a street network (generated by
# street_network_to_kml.py), models it as a graph, and calculates an
# optimal route that traverses every street at least once (solving the
# Chinese Postman Problem). It outputs the final route as a new KML file
# with timestamps for animation in Google Earth, and a text file with
# turn-by-turn directions.
#
# Prerequisites:
# - Python 3
# - 'fastkml' library: pip install fastkml
# - 'networkx' library: pip install networkx
# - 'haversine' library: pip install haversine
# - 'simplekml' library: pip install simplekml

import sys
import networkx as nx
from fastkml import kml
from haversine import haversine
import simplekml
from datetime import datetime, timedelta

# A tolerance for considering two coordinate points to be the same intersection.
# (Value is in degrees latitude/longitude).
COORDINATE_PRECISION = 4 # e.g., 1.123456

# Define an average walking speed in kilometers per hour.
WALKING_SPEED_KMH = 5.0

def parse_kml_to_graph(kml_file):
    """
    Parses a KML file and builds a graph representation of the street network.

    Args:
        kml_file (str): Path to the input KML file.

    Returns:
        networkx.MultiGraph: A graph where nodes are intersections and edges
                             are street segments.
    """
    print(f"Reading and parsing {kml_file}...")
    try:
        with open(kml_file, 'rt', encoding='utf-8') as f:
            doc = f.read().encode('utf-8')
        k = kml.KML()
        k = k.from_string(doc)
    except Exception as e:
        print(f"Error reading or parsing KML file: {e}", file=sys.stderr)
        return None

    graph = nx.MultiGraph()
    
    # Iterate through all folders and placemarks in the KML
    for feature in list(list(k.features)[0].features):
        if not hasattr(feature, 'geometry'):
            continue

        geom = feature.geometry
        # Coords are (lon, lat, alt), so we take the first two elements.
        coords = [(round(lon, COORDINATE_PRECISION), round(lat, COORDINATE_PRECISION)) for lon, lat, _ in geom.coords]
        
        # An edge is a segment between two consecutive points in the LineString.
        # In our new KML, each feature is already a single segment.
        for i in range(len(coords) - 1):
            start_node = coords[i]
            end_node = coords[i+1]

            # Calculate the distance (weight) of the edge.
            # haversine expects (lat, lon).
            distance = haversine(
                (start_node[1], start_node[0]),
                (end_node[1], end_node[0])
            )

            graph.add_edge(
                start_node,
                end_node,
                name=feature.name,
                weight=distance,
                coords=[start_node, end_node]
            )
            
    print(f"Graph built successfully with {graph.number_of_nodes()} nodes (intersections) and {graph.number_of_edges()} edges (street segments).")
    return graph

def generate_route_instructions(edge_list):
    """Generates simple turn-by-turn directions from the edge list."""
    if not edge_list:
        return "No route found."

    instructions = []
    
    # Start with the first street.
    current_street_name = edge_list[0][2].get('name', 'Unnamed Street')
    instructions.append(f"Start on {current_street_name}")
    
    for i in range(len(edge_list) - 1):
        next_edge_data = edge_list[i+1][2]
        next_street_name = next_edge_data.get('name', 'Unnamed Street')
        
        if current_street_name != next_street_name:
            instructions.append(f"Turn onto {next_street_name}")
            current_street_name = next_street_name
            
    instructions.append("Route finished.")
    return "\n".join(instructions)

def create_output_files(route_coords, route_timestamps, instructions_text, output_kml_file, output_txt_file):
    """Saves the final route to KML (with timestamps) and TXT files."""
    # 1. Initialize KML object
    kml = simplekml.Kml()
    kml.hint = 'gx:Track' # Hint to simplekml to use the correct namespace

    # 2. Define the styling for the route line
    # This style is reused by the track placemark
    style = simplekml.Style()
    style.linestyle.color = simplekml.Color.red  # A highly visible color
    style.linestyle.width = 4                    # A thick line
    
    # 3. Create the <Placemark> and the <gx:Track> element
    placemark = kml.newgxtrack(name="Planned Route", altitudemode=simplekml.AltitudeMode.clamptoground)
    placemark.style = style

    # 4. Populate the track with coordinates and times
    # simplekml handles the creation of <when> and <gx:coord> elements
    placemark.newgxcoord(route_coords)
    placemark.newwhen(route_timestamps)
    
    # Optional: Add a point style to show a marker at each position during playback
    # placemark.style.iconstyle.icon.href = 'http://maps.google.com/mapfiles/kml/shapes/placemark_circle.png'
    # placemark.style.iconstyle.scale = 1.0
    
    try:
        kml.save(output_kml_file)
        print(f"\nSuccessfully saved animated route to: {output_kml_file}")
    except Exception as e:
        print(f"Error saving KML file: {e}", file=sys.stderr)

    # Create TXT file for directions
    try:
        with open(output_txt_file, 'w', encoding='utf-8') as f:
            f.write(instructions_text)
        print(f"Successfully saved directions to: {output_txt_file}")
    except Exception as e:
        print(f"Error saving TXT file: {e}", file=sys.stderr)

def main():
    """Main execution function."""
    input_kml = "test_small.kml"
    output_route_kml = "planned_route.kml"
    output_route_txt = "route_directions2.txt"
    
    print("-" * 50)
    print("Street Network Route Planner")
    print("-" * 50)

    graph = parse_kml_to_graph(input_kml)
    if not graph:
        return

    if not nx.is_connected(graph):
        print("Warning: The street network is not fully connected.", file=sys.stderr)
        print("The route will be calculated for the largest connected area.", file=sys.stderr)
        largest_component = max(nx.connected_components(graph), key=len)
        graph = graph.subgraph(largest_component).copy()

    print("Solving the Chinese Postman Problem by making the graph Eulerian...")
    eulerian_graph = nx.eulerize(graph)
    print("Graph has been eulerized.")

    print("Calculating the final route (Eulerian circuit)...")
    start_node = list(eulerian_graph.nodes())[0]
    circuit_edge_keys = list(nx.eulerian_circuit(eulerian_graph, source=start_node))
    
    circuit_edges = []
    for u, v in circuit_edge_keys:
        # We need to find the specific edge instance, as there can be multiple.
        # This is a bit of a workaround to get the right edge data.
        edge_data = eulerian_graph.get_edge_data(u, v)
        # In a MultiGraph, edge_data is a dict of keys to attributes.
        # We assume taking the first one that hasn't been "used" works.
        # A more robust solution might be needed for complex graphs.
        key = list(edge_data.keys())[0]
        circuit_edges.append((u, v, edge_data[key]))
        
    print("Route calculated.")

    # Generate human-readable directions
    instructions = generate_route_instructions(circuit_edges)

    # Generate coordinates and timestamps for the KML animation
    print("Generating timestamps for route animation...")
    kml_coords = []
    kml_timestamps = []
    start_time = datetime(2025, 10, 19, 13, 44, 0) # Use a fixed start time
    current_time = start_time

    # Add the very first point of the route
    first_edge_coords = circuit_edges[0][2]['coords']
    if circuit_edges[0][0] != first_edge_coords[0]: # Ensure start node matches
        first_edge_coords = first_edge_coords[::-1]
    
    kml_coords.extend(first_edge_coords)
    kml_timestamps.append(start_time.isoformat() + "Z")

    # Estimate time for the first segment
    distance_km = circuit_edges[0][2]['weight']
    travel_time_seconds = (distance_km / WALKING_SPEED_KMH) * 3600
    current_time += timedelta(seconds=travel_time_seconds)
    kml_timestamps.append(current_time.isoformat() + "Z")

    # Loop through the rest of the edges
    for i in range(1, len(circuit_edges)):
        edge_data = circuit_edges[i][2]
        edge_coords = edge_data['coords']
        
        # Ensure the coordinate order matches the direction of travel
        if circuit_edges[i][0] != kml_coords[-1]:
             edge_coords = edge_coords[::-1]

        distance_km = edge_data['weight']
        travel_time_seconds = (distance_km / WALKING_SPEED_KMH) * 3600
        current_time += timedelta(seconds=travel_time_seconds)

        # Add all intermediate points, then the final point with its timestamp
        kml_coords.extend(edge_coords[1:])
        for _ in range(len(edge_coords) - 1):
             kml_timestamps.append(current_time.isoformat() + "Z")

    # Save the output files
    create_output_files(kml_coords, kml_timestamps, instructions, output_route_kml, output_route_txt)
    
    print("\nProcess complete.")

if __name__ == "__main__":
    main()

